diff --git a/drivers/mmc/card/Kconfig b/drivers/mmc/card/Kconfig
index 3b1f783..d0e9dc1 100644
--- a/drivers/mmc/card/Kconfig
+++ b/drivers/mmc/card/Kconfig
@@ -50,6 +50,33 @@ config MMC_BLOCK_BOUNCE
 
 	  If unsure, say Y here.
 
+config MMC_SLOTINDEX
+	bool "Use host index for enumerating mmxblkN"
+	depends on MMC_BLOCK
+	default n
+	help
+	  On embedded devices, often there is a combination of
+	  removable mmc devices (e.g. MMC/SD cards) and hard
+	  wired ones (e.g. eMMC). Depending on the hardware
+	  configuration, the 'mmcblkN' node might change if
+	  the removable device is available or not at boot time.
+
+	  E.g. if the removable device is attached at boot time,
+	  it might become mmxblk0. And the hard wired one mmcblk1.
+	  But if the removable device isn't there at boot time,
+	  the hard wired one will become mmcblk0. This makes it
+	  somehow difficult to hard code the root device to the
+	  non-removable device and boot fast.
+
+	  Enabling this option will simply associating 'N' of
+	  'mmcblkN' with the slot index instead of the dynamic
+	  name index. The slot index is always the same, ensuring
+	  that the non-removable mmc device is associated always
+	  with the same mmcblkN. Independent of the availability of
+	  the removable one.
+
+	  If unsure, say N here.
+
 config SDIO_UART
 	tristate "SDIO UART/GPS class support"
 	help
diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c
index 21056b9..bfaab74 100644
--- a/drivers/mmc/card/block.c
+++ b/drivers/mmc/card/block.c
@@ -1599,7 +1599,7 @@ static struct mmc_blk_data *mmc_blk_alloc_req(struct mmc_card *card,
 	 */
 
 	snprintf(md->disk->disk_name, sizeof(md->disk->disk_name),
-		 "mmcblk%d%s", md->name_idx, subname ? subname : "");
+		 "mmcblk%d%s", NAMEIDX, subname ? subname : "");
 
 	if (mmc_card_mmc(card))
 		blk_queue_logical_block_size(md->queue.queue,
diff --git a/drivers/usb/misc/usb3503.c b/drivers/usb/misc/usb3503.c
index be67bb7..071393d 100644
--- a/drivers/usb/misc/usb3503.c
+++ b/drivers/usb/misc/usb3503.c
@@ -165,21 +165,16 @@ static int usb3503_switch_mode(struct usb3503 *hub, enum usb3503_mode mode)
 
 	switch (mode) {
 	case USB3503_MODE_HUB:
-
-		// Hub Configuration Stage
-		val = usb3503_read_register(i2c, USB3503_SP_ILOCK);
-		dev_info(&i2c->dev, "USB3503_SP_ILOCK = 0x%02x\n",val);
-
 		/* SP_ILOCK: config_n for config */
-		err = usb3503_clear_bits(i2c, USB3503_SP_ILOCK,
+		err = usb3503_set_bits(i2c, USB3503_SP_ILOCK,
 				 USB3503_SPILOCK_CONFIG);
 		if (err < 0) {
 			dev_err(&i2c->dev, "USB3503_SPILOCK_CONFIG failed (%d) 1\n", err);
 			goto err_hubmode;
 		}
 
-		reg_data = (USB3503_SELF_BUS_PWR | USB3503_OCS_DISABLE);
-		/* CFG1 : SELF_BUS_PWR -> Self-Powerd operation */
+		reg_data = (USB3503_SELF_BUS_PWR | USB3503_OCS_DISABLE | USB3503_PPRTPWR_INDIVIDUAL);
+		/* CFG1 : SELF_BUS_PWR -> Self-Powered operation */
 		err = usb3503_write_register(i2c, USB3503_CFG1, reg_data);
 		if (err < 0) {
 			dev_err(&i2c->dev, "CFG1 failed (%d)\n", err);
@@ -194,21 +189,30 @@ static int usb3503_switch_mode(struct usb3503 *hub, enum usb3503_mode mode)
 			goto err_hubmode;
 		}
 
-		err = usb3503_clear_bits(i2c, USB3503_SP_ILOCK,
-					(USB3503_OCS_PINSEL | USB3503_PRTPWR_PINSEL));
+        err = usb3503_clear_bits(i2c, USB3503_SP_ILOCK, USB3503_OCS_PINSEL);
 		if (err < 0) {
 			dev_err(&i2c->dev, "USB3503_SPILOCK_CONFIG failed (%d) 2\n", err);
 			goto err_hubmode;
 		}
 
- 		/* USB3503_SP_ILOCK config_n lock */
- 		err = usb3503_set_bits(i2c, USB3503_SP_ILOCK,
-				 USB3503_SPILOCK_CONFIG);
+		err = usb3503_set_bits(i2c, USB3503_SP_ILOCK, USB3503_PRTPWR_PINSEL);
+		if (err < 0) {
+			dev_err(&i2c->dev, "USB3503_SPILOCK_CONFIG failed (%d) 2\n", err);
+			goto err_hubmode;
+		}
+
+ 		/* USB3503_SP_ILOCK config_n and connect_n lock */
+ 		err = usb3503_clear_bits(i2c, USB3503_SP_ILOCK,
+				 USB3503_SPILOCK_CONFIG | USB3503_SPILOCK_CONNECT);
 		if (err < 0) {
 			dev_err(&i2c->dev, "USB3503_SPILOCK_CONFIG failed (%d) 3\n", err);
 			goto err_hubmode;
 		}
 
+		// Hub Configuration Stage
+		val = usb3503_read_register(i2c, USB3503_SP_ILOCK);
+		dev_info(&i2c->dev, "USB3503_SP_ILOCK = 0x%02x\n",val);
+
 		hub->mode = mode;
 		usb3503_connect(hub->gpio_connect, 1);
 		dev_info(&i2c->dev, "switched to HUB mode\n");
diff --git a/include/linux/mmc/host.h b/include/linux/mmc/host.h
index 61a10c1..3be766c 100644
--- a/include/linux/mmc/host.h
+++ b/include/linux/mmc/host.h
@@ -453,4 +453,11 @@ static inline unsigned int mmc_host_clk_rate(struct mmc_host *host)
 	return host->ios.clock;
 }
 #endif
+
+#ifdef CONFIG_MMC_SLOTINDEX
+#define NAMEIDX (card->host->index)
+#else
+#define NAMEIDX (md->name_idx)
+#endif
+
 #endif /* LINUX_MMC_HOST_H */
